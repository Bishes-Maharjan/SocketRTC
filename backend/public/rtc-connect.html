<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>WebRTC Video Call</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: Arial, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        padding: 20px;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
        background: white;
        border-radius: 10px;
        padding: 30px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
      }

      h1 {
        text-align: center;
        color: #333;
        margin-bottom: 30px;
      }

      .join-section {
        margin-bottom: 20px;
      }

      .input-group {
        margin-bottom: 15px;
      }

      input {
        width: 100%;
        padding: 12px;
        border: 2px solid #ddd;
        border-radius: 5px;
        font-size: 16px;
        margin-bottom: 10px;
      }

      button {
        padding: 12px 24px;
        background: #667eea;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        transition: background 0.3s;
      }

      button:hover {
        background: #5568d3;
      }

      button:disabled {
        background: #ccc;
        cursor: not-allowed;
      }

      #status {
        padding: 10px;
        background: #f0f0f0;
        border-radius: 5px;
        margin-bottom: 15px;
        text-align: center;
        font-weight: bold;
      }

      #debugLog {
        max-height: 200px;
        overflow-y: auto;
        background: #f9f9f9;
        border: 1px solid #ddd;
        border-radius: 5px;
        padding: 10px;
        margin-bottom: 15px;
        font-family: monospace;
        font-size: 12px;
      }

      .log-entry {
        margin-bottom: 5px;
        padding: 3px;
      }

      .log-info {
        color: #0066cc;
      }
      .log-success {
        color: #00aa00;
      }
      .log-error {
        color: #cc0000;
      }
      .log-warning {
        color: #ff8800;
      }

      .controls {
        display: flex;
        gap: 10px;
        justify-content: center;
        align-items: center;
      }

      .control-btn {
        width: 50px;
        height: 50px;
        border-radius: 50%;
        font-size: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 0;
      }

      .video-container {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 20px;
        margin-top: 20px;
      }

      .video-wrapper {
        position: relative;
        background: #000;
        border-radius: 10px;
        overflow: hidden;
        aspect-ratio: 4/3;
      }

      .video-wrapper.waiting {
        display: flex;
        align-items: center;
        justify-content: center;
        background: #333;
      }

      .video-wrapper video {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      .video-label {
        position: absolute;
        bottom: 10px;
        left: 10px;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 5px 10px;
        border-radius: 5px;
        font-size: 14px;
      }

      .waiting-text {
        color: white;
        font-size: 18px;
      }

      .hidden {
        display: none;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>ðŸŽ¥ WebRTC Video Call</h1>

      <div class="join-section" id="joinSection">
        <div class="input-group">
          <input
            type="text"
            id="token"
            placeholder="Enter Your Token"
            value=""
            autocomplete="on"
          />
        </div>
        <div class="input-group">
          <input
            type="text"
            id="roomId"
            placeholder="Enter Room ID"
            value="692d4d55f4ecb3c5e7ab99e1"
            autocomplete="on"
          />
          <button id="joinBtn" onclick="joinRoom()">Join Room</button>
        </div>
      </div>

      <div class="join-section hidden" id="controlSection">
        <div id="status">Not connected</div>
        <div id="debugLog"></div>
        <div class="controls">
          <button
            class="control-btn mute-btn"
            id="muteBtn"
            onclick="toggleMute()"
          >
            ðŸŽ¤
          </button>
          <button
            class="control-btn video-btn"
            id="videoBtn"
            onclick="toggleVideo()"
          >
            ðŸ“¹
          </button>
          <button onclick="leaveRoom()" style="margin-left: 10px">
            Leave Room
          </button>
        </div>
      </div>

      <div class="video-container hidden" id="videoContainer">
        <div class="video-wrapper waiting" id="video1">
          <div class="waiting-text">Waiting...</div>
        </div>
        <div class="video-wrapper waiting" id="video2">
          <div class="waiting-text">Waiting...</div>
        </div>
      </div>
    </div>

    <script src="https://cdn.socket.io/4.6.0/socket.io.min.js"></script>
    <script>
      const configuration = {
        iceServers: [
          { urls: 'stun:stun.l.google.com:19302' },
          { urls: 'stun:stun1.l.google.com:19302' },
        ],
      };

      let socket;
      let localStream;
      let remotePeerConnection;
      let remotePeerId;
      let currentRoom;
      let userId;
      let userName;
      let isAudioMuted = false;
      let isVideoOff = false;

      const videoContainer = document.getElementById('videoContainer');
      const status = document.getElementById('status');
      const joinSection = document.getElementById('joinSection');
      const controlSection = document.getElementById('controlSection');
      const muteBtn = document.getElementById('muteBtn');
      const videoBtn = document.getElementById('videoBtn');
      const video1 = document.getElementById('video1');
      const video2 = document.getElementById('video2');
      const debugLog = document.getElementById('debugLog');

      // Debug logging
      function log(message, type = 'info') {
        console.log(`[${type.toUpperCase()}]`, message);
        const entry = document.createElement('div');
        entry.className = `log-entry log-${type}`;
        entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
        debugLog.appendChild(entry);
        debugLog.scrollTop = debugLog.scrollHeight;
      }

      async function joinRoom() {
        const token = document.getElementById('token').value.trim();
        const roomId = document.getElementById('roomId').value.trim();

        if (!roomId) {
          alert('Please enter a room ID');
          return;
        }

        if (!token) {
          alert('Please enter your token');
          return;
        }

        try {
          log('Requesting media devices...', 'info');

          // Get media FIRST
          localStream = await navigator.mediaDevices.getUserMedia({
            video: true,
            audio: true,
          });

          log(
            'âœ“ Got local stream with ' +
              localStream.getTracks().length +
              ' tracks',
            'success',
          );
          localStream.getTracks().forEach((track) => {
            log(`  - ${track.kind} track: ${track.label}`, 'info');
          });

          // Show local video immediately
          videoContainer.classList.remove('hidden');
          setVideo(video1, localStream, 'You (Local)');
          log('âœ“ Local video displayed', 'success');

          // Initialize socket AFTER we have the stream
          log('Connecting to signaling server...', 'info');
          socket = io('http://localhost:3001', {
            auth: {
              token: token,
            },
          });

          currentRoom = roomId;

          // Set up socket listeners and wait for connection
          await setupSocketListeners(roomId);
        } catch (error) {
          log('âœ— Error accessing media devices: ' + error.message, 'error');
          console.error('Error accessing media devices:', error);
          alert(
            'Could not access camera/microphone. Please check permissions.',
          );
        }
      }

      function setupSocketListeners(roomId) {
        return new Promise((resolve, reject) => {
          socket.on('connect', () => {
            log(
              'âœ“ Connected to signaling server (socket.id: ' + socket.id + ')',
              'success',
            );

            // Now join the room after connection is established
            log('Joining room: ' + roomId, 'info');
            socket.emit('join-video-room', roomId);
            resolve();
          });

          socket.on('disconnect', () => {
            log('âœ— Disconnected from signaling server', 'error');
            if (currentRoom) {
              status.textContent = 'Connection lost. Please rejoin.';
            }
          });

          socket.on('connect_error', (error) => {
            log('âœ— Connection error: ' + error.message, 'error');
            reject(error);
          });

          socket.on('error', (error) => {
            log('âœ— Socket error: ' + JSON.stringify(error), 'error');
          });

          socket.on(
            'chatting-partner',
            async ({ chatPartner, currentUserId, username }) => {
              userId = currentUserId;
              userName = username;

              log('âœ“ Joined room successfully', 'success');
              log('Your userId: ' + currentUserId, 'info');
              log('Your username: ' + username, 'info');
              log('Chat partner: ' + (chatPartner || 'None (waiting)'), 'info');

              // Update UI
              joinSection.classList.add('hidden');
              controlSection.classList.remove('hidden');
              status.textContent = `Connected to room as ${username}`;

              // If there's a chat partner, initiate connection
              if (chatPartner) {
                log('Initiating peer connection with: ' + chatPartner, 'info');
                const peerConnection = await createPeerConnection(chatPartner);

                // Create and send offer
                log('Creating offer...', 'info');
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);
                log('âœ“ Local description set (offer)', 'success');

                log('Sending offer to room: ' + currentRoom, 'info');
                socket.emit('offer', {
                  roomId: currentRoom,
                  offer,
                });
              } else {
                log('Waiting for another user to join...', 'warning');
                status.textContent = 'Waiting for another user...';
              }
            },
          );

          socket.on('user-joined', async (peerId) => {
            log('New user joined: ' + peerId, 'info');
            status.textContent = 'Another user is connecting...';
          });

          socket.on('offer', async ({ from, offer }) => {
            log('Received offer from: ' + from, 'info');

            const peerConnection = await createPeerConnection(from);

            log('Setting remote description (offer)...', 'info');
            await peerConnection.setRemoteDescription(
              new RTCSessionDescription(offer),
            );
            log('âœ“ Remote description set (offer)', 'success');

            log('Creating answer...', 'info');
            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);
            log('âœ“ Local description set (answer)', 'success');

            log('Sending answer to room: ' + currentRoom, 'info');
            socket.emit('answer', {
              roomId: currentRoom,
              answer,
            });
          });

          socket.on('answer', async ({ from, answer }) => {
            log('Received answer from: ' + from, 'info');

            if (remotePeerConnection) {
              log('Setting remote description (answer)...', 'info');
              await remotePeerConnection.setRemoteDescription(
                new RTCSessionDescription(answer),
              );
              log('âœ“ Remote description set (answer)', 'success');
            } else {
              log('âœ— No peer connection exists to set answer', 'error');
            }
          });

          socket.on('ice-candidate', async ({ sender, candidate }) => {
            log('Received ICE candidate from: ' + sender, 'info');

            if (remotePeerConnection) {
              try {
                await remotePeerConnection.addIceCandidate(
                  new RTCIceCandidate(candidate),
                );
                log('âœ“ Added ICE candidate', 'success');
              } catch (error) {
                log('âœ— Error adding ICE candidate: ' + error.message, 'error');
              }
            } else {
              log('âœ— No peer connection exists for ICE candidate', 'warning');
            }
          });

          socket.on('user-disconnected', (disconnectedUserId) => {
            log('User disconnected: ' + disconnectedUserId, 'warning');

            if (disconnectedUserId === remotePeerId) {
              if (remotePeerConnection) {
                remotePeerConnection.close();
                remotePeerConnection = null;
              }

              setWaiting(video2, 'User disconnected');
              remotePeerId = null;
              status.textContent = `Waiting for another user in room: ${currentRoom}`;
            }
          });
        });
      }

      function setVideo(wrapper, stream, labelText) {
        log('Setting video for: ' + labelText, 'info');

        // Clear existing content
        wrapper.innerHTML = '';
        wrapper.classList.remove('waiting');

        // Create video element
        const video = document.createElement('video');
        video.autoplay = true;
        video.playsinline = true;
        video.muted =
          labelText.includes('Local') || labelText.includes('(You)');
        video.srcObject = stream;

        // Add event listeners for debugging
        video.onloadedmetadata = () => {
          log('âœ“ Video metadata loaded for: ' + labelText, 'success');
        };

        video.onplay = () => {
          log('âœ“ Video playing for: ' + labelText, 'success');
        };

        video.onerror = (e) => {
          log('âœ— Video error for ' + labelText + ': ' + e, 'error');
        };

        // Force play
        video
          .play()
          .then(() =>
            log('âœ“ Video play() succeeded for: ' + labelText, 'success'),
          )
          .catch((e) =>
            log(
              'âœ— Video play() failed for ' + labelText + ': ' + e.message,
              'error',
            ),
          );

        // Create label
        const label = document.createElement('div');
        label.className = 'video-label';
        label.textContent = labelText;

        wrapper.appendChild(video);
        wrapper.appendChild(label);
      }

      function setWaiting(wrapper, text = 'Waiting...') {
        wrapper.innerHTML = '';
        wrapper.classList.add('waiting');
        const waitingText = document.createElement('div');
        waitingText.className = 'waiting-text';
        waitingText.textContent = text;
        wrapper.appendChild(waitingText);
      }

      function leaveRoom() {
        log('Leaving room...', 'info');

        if (remotePeerConnection) {
          remotePeerConnection.close();
          remotePeerConnection = null;
        }

        if (localStream) {
          localStream.getTracks().forEach((track) => track.stop());
          localStream = null;
        }

        setWaiting(video1);
        setWaiting(video2);

        if (socket && currentRoom) {
          socket.emit('leave-room', { roomId: currentRoom });
          socket.disconnect();
          socket = null;
        }

        controlSection.classList.add('hidden');
        joinSection.classList.remove('hidden');
        videoContainer.classList.add('hidden');
        status.textContent = 'Disconnected';

        currentRoom = null;
        userName = null;
        userId = null;
        remotePeerId = null;
        isAudioMuted = false;
        isVideoOff = false;
        muteBtn.textContent = 'ðŸŽ¤';
        videoBtn.textContent = 'ðŸ“¹';
        debugLog.innerHTML = '';

        log('âœ“ Left room and cleaned up', 'success');
      }

      function toggleMute() {
        if (localStream) {
          const audioTrack = localStream.getAudioTracks()[0];
          audioTrack.enabled = !audioTrack.enabled;
          isAudioMuted = !audioTrack.enabled;
          muteBtn.textContent = isAudioMuted ? 'ðŸ”‡' : 'ðŸŽ¤';
          log(isAudioMuted ? 'Audio muted' : 'Audio unmuted', 'info');
        }
      }

      function toggleVideo() {
        if (localStream) {
          const videoTrack = localStream.getVideoTracks()[0];
          videoTrack.enabled = !videoTrack.enabled;
          isVideoOff = !videoTrack.enabled;
          videoBtn.textContent = isVideoOff ? 'ðŸ“·' : 'ðŸ“¹';
          log(isVideoOff ? 'Video disabled' : 'Video enabled', 'info');
        }
      }

      async function createPeerConnection(peerId) {
        log('Creating peer connection with: ' + peerId, 'info');

        const peerConnection = new RTCPeerConnection(configuration);
        remotePeerConnection = peerConnection;
        remotePeerId = peerId;

        // Add local tracks
        localStream.getTracks().forEach((track) => {
          log(
            'Adding local ' + track.kind + ' track to peer connection',
            'info',
          );
          peerConnection.addTrack(track, localStream);
        });

        // Handle ICE candidates
        peerConnection.onicecandidate = (event) => {
          if (event.candidate) {
            log('Sending ICE candidate to room: ' + currentRoom, 'info');
            socket.emit('ice-candidate', {
              roomId: currentRoom,
              candidate: event.candidate,
            });
          } else {
            log('ICE gathering complete', 'success');
          }
        };

        // Handle incoming tracks
        peerConnection.ontrack = (event) => {
          log('âœ“ Received remote ' + event.track.kind + ' track', 'success');

          if (event.streams && event.streams[0]) {
            log(
              'âœ“ Remote stream received with ' +
                event.streams[0].getTracks().length +
                ' tracks',
              'success',
            );
            setVideo(video2, event.streams[0], 'Remote User');
            status.textContent = `Connected with remote peer`;
          } else {
            log('âœ— No streams in track event', 'error');
          }
        };

        // Monitor connection state
        peerConnection.onconnectionstatechange = () => {
          log('Connection state: ' + peerConnection.connectionState, 'info');
          if (peerConnection.connectionState === 'connected') {
            log('âœ“ Peer connection established!', 'success');
            status.textContent = `Connected in room: ${currentRoom}`;
          } else if (
            peerConnection.connectionState === 'failed' ||
            peerConnection.connectionState === 'disconnected'
          ) {
            log('âœ— Connection ' + peerConnection.connectionState, 'error');
            setWaiting(video2, 'Connection lost');
          }
        };

        peerConnection.oniceconnectionstatechange = () => {
          log(
            'ICE connection state: ' + peerConnection.iceConnectionState,
            'info',
          );
        };

        peerConnection.onicegatheringstatechange = () => {
          log(
            'ICE gathering state: ' + peerConnection.iceGatheringState,
            'info',
          );
        };

        peerConnection.onsignalingstatechange = () => {
          log('Signaling state: ' + peerConnection.signalingState, 'info');
        };

        return peerConnection;
      }

      // Enter key handlers
      document.getElementById('token').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          document.getElementById('roomId').focus();
        }
      });

      document.getElementById('roomId').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          joinRoom();
        }
      });
    </script>
  </body>
</html>
